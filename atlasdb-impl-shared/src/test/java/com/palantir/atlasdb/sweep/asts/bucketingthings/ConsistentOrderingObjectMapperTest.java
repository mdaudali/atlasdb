/*
 * (c) Copyright 2024 Palantir Technologies Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.palantir.atlasdb.sweep.asts.bucketingthings;

import static org.assertj.core.api.Assertions.assertThat;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.BaseEncoding;
import com.palantir.conjure.java.serialization.ObjectMappers;
import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.immutables.value.Value;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

public final class ConsistentOrderingObjectMapperTest {
    private static final ObjectMapper JSON_OBJECT_MAPPER =
            ConsistentOrderingObjectMapper.configureConsistentOrderingObjectMapper(ObjectMappers.newClientJsonMapper());

    private static final TestObject ALL_PARAMS =
            ImmutableTestObject.builder().b("test").a(true).a123(123).build();
    private static final TestObject EMPTY_OPTIONAL = ImmutableTestObject.builder()
            .b("test")
            .a(Optional.empty())
            .a123(123)
            .build();
    private static final TestObject NULL_VALUE =
            ImmutableTestObject.builder().b(null).a(true).a123(123).build();

    // This case exists to catch a bug where the object mapper is set to NON_DEFAULT rather than NON_ABSENT
    // In this case, the 0 field will not be serialised, but then deserialisation fails because the value is not present
    private static final TestObject ZERO_INT_VALUE =
            ImmutableTestObject.builder().b("test").a(true).a123(0).build();

    // Testing against a raw json because the output must always be _syntactically_ identical, not just
    // _semantically_ identical. This also applies to the smile version below.
    private static final Map<TestObject, String> GOLDEN_JSON = ImmutableMap.of(
            ALL_PARAMS, "{\"a\":true,\"a123\":123,\"b\":\"test\"}", // alphabetical
            EMPTY_OPTIONAL, "{\"a123\":123,\"b\":\"test\"}", // optional not serialised
            NULL_VALUE, "{\"a\":true,\"a123\":123}", // null not serialised
            ZERO_INT_VALUE, "{\"a\":true,\"a123\":0,\"b\":\"test\"}"); // 0 is still serialised

    // Unlike the JSON examples above, the smile was generated by running the object mapper and using the output
    // as the golden example. The JSON example, along with a code review of the fact that both object mappers are
    // constructed in a similar way, should be sufficient to show that the smile format is consistent with the JSON.
    private static final Map<TestObject, byte[]> GOLDEN_SMILE = ImmutableMap.of(
            ALL_PARAMS, BaseEncoding.base64().decode("OikKBfqAYSODYTEyMyQDtoBiQ3Rlc3T7"),
            EMPTY_OPTIONAL, BaseEncoding.base64().decode("OikKBfqDYTEyMyQDtoBiQ3Rlc3T7="),
            NULL_VALUE, BaseEncoding.base64().decode("OikKBfqAYSODYTEyMyQDtvs="),
            ZERO_INT_VALUE, BaseEncoding.base64().decode("OikKBfqAYSODYTEyM8CAYkN0ZXN0+w=="));

    @ParameterizedTest(name = "{0}")
    @MethodSource("exampleObjectAndSerialisedJsonForm")
    public void jsonMapperEmitsSyntacticallyMatchingJson(TestObject exampleObject, String expectedJson)
            throws JsonProcessingException {
        assertThat(JSON_OBJECT_MAPPER.writeValueAsString(exampleObject)).isEqualTo(expectedJson);
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("exampleObjectAndSerialisedSmileForm")
    public void smileMapperEmitsConsistentSmile(TestObject exampleObject, byte[] expectedSmile)
            throws JsonProcessingException {
        assertThat(ConsistentOrderingObjectMapper.OBJECT_MAPPER.writeValueAsBytes(exampleObject))
                .isEqualTo(expectedSmile);
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("exampleObjectAndSerialisedSmileForm")
    public void smileMapperCanDeserialiseOldValues(TestObject exampleObject, byte[] expectedSmile) throws IOException {
        assertThat(ConsistentOrderingObjectMapper.OBJECT_MAPPER.readValue(expectedSmile, TestObject.class))
                .isEqualTo(exampleObject);
    }

    @Test
    public void smileMapperCanIgnoreUnknownValues() throws IOException {
        SuperSetTestObject superSetTestObject = ImmutableSuperSetTestObject.builder()
                .a(true)
                .a123(123)
                .b("test")
                .newValueToIgnore(456)
                .build();

        TestObject expectedTestObject =
                ImmutableTestObject.builder().a(true).a123(123).b("test").build();

        byte[] smile = ConsistentOrderingObjectMapper.OBJECT_MAPPER.writeValueAsBytes(superSetTestObject);
        TestObject deserialised = ConsistentOrderingObjectMapper.OBJECT_MAPPER.readValue(smile, TestObject.class);
        assertThat(deserialised).isEqualTo(expectedTestObject);
    }

    private static Stream<Arguments> exampleObjectAndSerialisedJsonForm() {
        return GOLDEN_JSON.entrySet().stream().map(entry -> Arguments.of(entry.getKey(), entry.getValue()));
    }

    private static Stream<Arguments> exampleObjectAndSerialisedSmileForm() {
        return GOLDEN_SMILE.entrySet().stream().map(entry -> Arguments.of(entry.getKey(), entry.getValue()));
    }

    @JsonSerialize(as = ImmutableTestObject.class)
    @JsonDeserialize(as = ImmutableTestObject.class)
    @Value.Immutable
    interface TestObject {
        // Ordered intentionally non-alphabetically to avoid a case where it happens to be ordered by declaration order
        // for a given run.
        @Nullable
        String b();

        Optional<Boolean> a();

        int a123();
    }

    @JsonSerialize(as = ImmutableSuperSetTestObject.class)
    @JsonDeserialize(as = ImmutableSuperSetTestObject.class)
    @Value.Immutable
    interface SuperSetTestObject {
        String b();

        Optional<Boolean> a();

        int a123();

        int newValueToIgnore();
    }
}
